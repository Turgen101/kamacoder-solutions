# 74. 子串简写

[题目链接](https://kamacoder.com/problempage.php?pid=1113)

## C

## C++
**方法一：二分搜索**

​	题意：字符串中有多少个长度大于等于$k$ 的，且首字符为$c1$ ，尾字符为$c2$ 的子串？字符串长度为$5e5$ ，盲猜时间复杂度是$O(nlogn)$ 或者$O(n)$ （注意这里没说一定满足$c1≠c2$ ）

​	令$a[i]$ 为首字符出现位置的数组，例如$a[1]=2$ 代表第$1$ 个$c1$ 字符出现的位置是$2$ ，同理再令$b[i]$ 保存尾字符出现位置，然后$lena$ 代表记录了多少个$c_1$ ，$lenb$同理 。

​	我们每遍历一个$a[i]$ ，然后寻找第一个下标位置大于等于$a[i]+k$ 的$b[j]$ ，然后说明从$j$ 开始，$b[j],b[j+1]$ 以及$b[lenb]$ 都能与其组成一个长度一定不小于$k$的合法子串，这样以来时间复杂度是$O(nlogn)$  

```C++
#include <iostream>
using namespace std;
const int N=5e5+7;
string s;
int a[N],b[N];
int k,lena,lenb;
char c1,c2;

int bs(int x){
	int l=0,r=lenb;
	while(l<r){
		int mid=(l+r)>>1;
		if(b[mid]>=x)r=mid;
		else l=mid+1;
	}
	return l;
}
int main(){
	ios::sync_with_stdio(false),cin.tie(0);
	cin>>k>>s>>c1>>c2;
	for(int i=0;i<s.size();i++){
		if(s[i]==c1)a[lena++]=i;
		if(s[i]==c2)b[lenb++]=i;
	}
	long long res=0;
	for(int i=0;i<lena;i++){
		res+=lenb-bs(a[i]+k-1);//找到第一个大于等于k的 
	}
	cout<<res;
	return 0;
}
```

**方法二：双指针**

​	我们不妨设$p1$ 为记录$a$ 数组的指针，$p2$ 同理。

​	当$a[p1]$ 与$b[p2]$ 的长度足够$k$ 了，说明有$lenb-p2$ 个尾字符可以与$p1$ 匹配，此时$p2$ 无需回退，因为$p1$ 增长后，只会对$b$ 的要求更严格，$p1$ 还比较小的时候，$p2$ 前面的下标都不够了，更不可能增大后还够，所以两个指针都是单调递增移动的，所以是双指针解法，时间复杂度是$O(n)$ 

```C++
#include <iostream>
using namespace std;
const int N=5e5+7;
string s;
int a[N],b[N];
int k,lena,lenb;
char c1,c2;

int main(){
	ios::sync_with_stdio(false),cin.tie(0);
	cin>>k>>s>>c1>>c2;
	for(int i=0;i<s.size();i++){
		if(s[i]==c1)a[lena++]=i;
		if(s[i]==c2)b[lenb++]=i;
	}
	long long res=0;
	int p1=0,p2=0;
	while(p1<lena&&p2<lenb){
		int len=b[p2]-a[p1]+1;//形成的子串长度 
		if(len>=k){
			res+=lenb-p2;
			p1++;
		}
		else p2++;
	}
	cout<<res;
	return 0;
}
```

**方法三：前缀和**

​	写到这里其实明白了：这道题的瓶颈就在于怎么寻找`当前尾字符能与之构成长度大于等于k的首字符个数` ，不难想到区间个数询问，也就是前缀和维护。

​	记$pre[i]$ 为前$i$ 个字符中首字符出现的次数，每遍历一个尾字符，有效的首字符个数就是$pre[i-k+1]$ 

```C++
#include <iostream>
#include <cstring>
using namespace std;
const int N=5e5+7;
int pre[N];
char s[N];
int k;
char c1,c2;

int main(){
	ios::sync_with_stdio(false),cin.tie(0);
	cin>>k>>s+1>>c1>>c2;
	int n=strlen(s+1);
	long long res=0;
	for(int i=1;i<=n;i++){
		pre[i]=pre[i-1];
		if(s[i]==c1)pre[i]++;
		if(i>=k&&s[i]==c2){
			res+=pre[i-k+1];
		}
	}
	cout<<res;
}
```


## Java

## Python

## JS

## Go
